antipattern_type: Cyclic Hierarchy
definition: This anti-pattern refers to the mistake of directly referencing a subtype from a supertype. Therefore, it implies that there are circular dependencies between the namespaces containing subtype and supertype.
examples:
  - example_id: "001"
    description: |
      This fix removes the circular dependency between `BaseComponent` and `AdvancedComponent` by extracting the 
      shared logic into a new interface `ComponentBehavior`, which both classes can depend on. 
      Now, `BaseComponent` no longer depends on its own subtype `AdvancedComponent`, 
      eliminating the cyclic reference and making the hierarchy acyclic and more maintainable.

    before_code:
      BaseComponent.java: |
        package core;

        import extension.AdvancedComponent;

        public abstract class BaseComponent {
            protected void initialize() {
                // Problematic: references a subtype directly
                AdvancedComponent.logInitialization();
            }

            public abstract void render();
        }

      AdvancedComponent.java: |
        package extension;

        import core.BaseComponent;

        public class AdvancedComponent extends BaseComponent {

            public static void logInitialization() {
                System.out.println("AdvancedComponent initialized.");
            }

            @Override
            public void render() {
                System.out.println("Rendering AdvancedComponent...");
            }
        }

    after_code:
      ComponentBehavior.java: |
        package shared;

        public interface ComponentBehavior {
            void logInitialization();
        }

      BaseComponent.java: |
        package core;

        import shared.ComponentBehavior;

        public abstract class BaseComponent {
            private final ComponentBehavior behavior;

            public BaseComponent(ComponentBehavior behavior) {
                this.behavior = behavior;
            }

            protected void initialize() {
                behavior.logInitialization();
            }

            public abstract void render();
        }

      AdvancedComponent.java: |
        package extension;

        import core.BaseComponent;
        import shared.ComponentBehavior;

        public class AdvancedComponent extends BaseComponent implements ComponentBehavior {

            public AdvancedComponent() {
                super(new AdvancedComponentLogger());
            }

            @Override
            public void render() {
                System.out.println("Rendering AdvancedComponent...");
            }

            private static class AdvancedComponentLogger implements ComponentBehavior {
                @Override
                public void logInitialization() {
                    System.out.println("AdvancedComponent initialized.");
                }
            }
        }